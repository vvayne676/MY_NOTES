## Abstract
### 遍历
是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式
### 子问题
是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。



#### 快排
```python
from typing import List

def partition(nums: List[int], lo: int, hi: int) -> int:
    pivot = nums[hi]  # 选取最后一个元素作为基准
    i = lo  # i 指向 <= pivot 区间的尾部

    for j in range(lo, hi):  # 遍历 lo 到 hi-1
        if nums[j] <= pivot:
            nums[i], nums[j] = nums[j], nums[i]  # 交换元素
            i += 1

    nums[i], nums[hi] = nums[hi], nums[i]  # 最后将 pivot 放到正确位置
    return i  # 返回 pivot 的最终位置


# 前序
def sort(nums: List[int], lo: int, hi: int):
    if lo >= hi:
        return
    # ****** 前序位置 ******
    # 对 nums[lo..hi] 进行切分，将 nums[p] 排好序
    # 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
    p = partition(nums, lo, hi)

    # 去左右子数组进行切分
    sort(nums, lo, p - 1)
    sort(nums, p + 1, hi)
```

#### 归并
```python
from typing import List


# 定义：排序 nums[lo..hi]
def sort(nums: List[int], lo: int, hi: int) -> None:
    if lo == hi:
        return
    mid = (lo + hi) // 2
    # 利用定义，排序 nums[lo..mid]
    sort(nums, lo, mid)
    # 利用定义，排序 nums[mid+1..hi]
    sort(nums, mid + 1, hi)

    # ****** 后序位置 ******
    # 此时两部分子数组已经被排好序
    # 合并两个有序数组，使 nums[lo..hi] 有序
    merge(nums, lo, mid, hi)

def merge(nums: List[int], lo: int, mid: int, hi: int) -> None:
    # 复制两个有序子数组
    left = nums[lo:mid+1]
    right = nums[mid+1:hi+1]

    i = j = 0  # i 指向 left，j 指向 right
    k = lo     # k 是原数组 nums 的写入位置

    # 合并两个有序数组
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            nums[k] = left[i]
            i += 1
        else:
            nums[k] = right[j]
            j += 1
        k += 1

    # 剩余部分直接复制
    while i < len(left):
        nums[k] = left[i]
        i += 1
        k += 1

    while j < len(right):
        nums[k] = right[j]
        j += 1
        k += 1

```