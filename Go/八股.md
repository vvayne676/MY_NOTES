1. waitgroup 和 channel的再并发时候的应用场景和异同？
* sync.WaitGroup - 用于等待一组 Goroutine 完成任务, 确保所有任务执行完毕后再继续后续逻辑。简单同步无需 Goroutine 间通信, 只需确保任务完成。计数器完成
    1. goroutine 内部调用 wg.Add() Deadlock
    2. 没有 wg.Done() Deadlock
    3. goroutine panic没有捕获
    4. waitgroup 计数器为负或者 wg.Add(-n) panic
* channel - Goroutine 间的通信和同步, 支持数据传递和协调
    1. for...range Channel,没有关闭 Deadlock
    2. 已经关闭的channel发数据 panic
    3. channel没有空间还往里面发数据 阻塞甚至死锁
    4. 重复关闭一个channel (多个goroutine 尝试关闭一个channel)
* 结合
    1. wait之前关闭channel
    2. Goroutine 调度由 Go 运行时控制, 执行顺序不可预测。

2. map 和 sync.map

|特性	|普通 map|	sync.Map|
|:-------|:--------|:---------|
|并发安全性|	非线程安全|	线程安全|
|性能特点|	单线程性能高|	读多写少场景性能更优|
|初始化要求|	必须用 make 初始化|	零值可用（无需初始化）|
|API 接口|	直接读写 (m[key]=val)	|专用方法 (Store, Load 等)|
|遍历方式|	for range|	.Range(func)|
|内存占用|	更低|	更高（为并发优化）|
|适用场景|	单线程/需锁控制的并发场景|	高并发读多写少场景|

sync.Map 的并发读性能通常比普通 map + RWMutex 高 2~5 倍
写操作频繁时, 普通 map + Mutex 性能更高


3. slice
包含指向 数组的指针,长度,容量大小
因为golang是值传递
```golang
var x=[]string{"1","2","3"}
func xx(y []string){
    y=append(y,"4")
}
```
以上这种情况如果扩容了那 x 还是 1,2,3 y就是1,2,3,4了 如果没扩容 x会变成 1,2,3,4

4. interface
```golang
// 空接口 var x interface{}
type eface struct {
    _type *_type         // 具体类型元信息
    data  unsafe.Pointer // 指向具体数据的指针
}
// 非空接口 
// type Sparker interface (Spark(p []byte) (n int, err error)){}
type iface struct {
    tab  *itab        // 接口表, 存储类型和方法信息
    data unsafe.Pointer // 指向具体数据的指针
}
type itab struct {
    inter *interfacetype // 接口类型元信息（方法签名）
    _type *_type         // 具体类型元信息
    hash  uint32         // 类型哈希, 用于快速比较
    _     [4]byte        // 填充
    fun   [1]uintptr     // 方法表, 指向具体类型的方法地址（实际大小动态）
}

type Type struct {
	Size_       uintptr
	PtrBytes    uintptr // number of (prefix) bytes in the type that can contain pointers
	Hash        uint32  // hash of type; avoids computation in hash tables
	TFlag       TFlag   // extra type information flags
	Align_      uint8   // alignment of variable with this type
	FieldAlign_ uint8   // alignment of struct field with this type
	Kind_       Kind    // enumeration for C
    Equal func(unsafe.Pointer, unsafe.Pointer) bool
    GCData    *byte
	Str       NameOff // string form
	PtrToThis TypeOff // type for pointer to this type, may be zero
}
```

5. 结构体匿名字段
```golang
type Person struct {
    Name string
    Age  int
}
// 定义另一个结构体, 嵌入Person
type Employee struct {
    Person // 嵌入结构体, 不需要字段名
    Company string
}
func main() {
    e := Employee{
        Person: Person{
            Name: "Alice",
            Age:  30,
        },
        Company: "Acme Corp",
    }

    // 可以直接访问嵌入结构体的字段和方法
    fmt.Println(e.Name)       // 输出: Alice
    fmt.Println(e.Company)    // 输出: Acme Corp
    e.Greet()                 // 输出: Hello, my name is Alice and I am 30 years old.
}
```

6. time.After 和 context.WithTimeout

* time.After 是一个便捷函数, 内部调用 time.NewTimer(d) 创建定时器, 返回定时器的 Channel（timer.C）
* context.WithTimeout 内部也是一个timer.NewTimer 配合 context.Cancel 实现

WithTimeout 创建上下文, 支持超时、取消和上下文树, 适合复杂并发；time.After 返回超时 Channel, 适合简单超时, 无取消控制
```golang
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel() // 始终 cancel()
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    <-ctx.Done() // 通知goroutine关闭了
    fmt.Println("超时")
}()
wg.Wait()


var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    select {
    case <-time.After(1 * time.Second): // 获取
        fmt.Println("超时")
    }
}()
wg.Wait()

// time.After
timer := time.NewTimer(1 * time.Second)
defer timer.Stop()
<-timer.C
```
time.After 的坑在于 for 循环中每次都会创建一个 ticker 循环中快速累积 未读取的 Channel 和定时器延迟垃圾回收. 在高频循环中, 定时器和 Channel 数量快速累积, 尤其在长时间运行的程序（如服务器）中, 可能导致内存使用激增, 甚至程序崩溃

7. waitGroup
```golang
type WaitGroup struct {
	noCopy noCopy

	state atomic.Uint64 // high 32 bits are counter, low 32 bits are waiter count.
	sema  uint32
}
```
拷贝 WaitGroup 会创建新的结构体实例, 包含独立的 state1（计数器和信号量）。
原 WaitGroup 和拷贝的 WaitGroup 不再共享状态, 导致计数器不同步

8. channel
```
+-----------------------+
|       hchan           |
+-----------------------+
| qcount   |  uint      |  // 当前队列中的元素数
| dataqsiz |  uint      |  // 缓冲区大小（环形缓冲区容量）
| buf      | *buffer    |  // 指向环形缓冲区
| elemsize |  uint16    |  // 元素大小
| closed   |  uint32    |  // 是否关闭（0=未关闭，1=已关闭）
| elemtype |  *_type    |  // 元素类型
| sendx    |  uint      |  // 发送索引
| recvx    |  uint      |  // 接收索引
| recvq    |  waitq     |  // 等待接收的 goroutine 队列
| sendq    |  waitq     |  // 等待发送的 goroutine 队列
| lock     |  mutex     |  // 互斥锁
+-----------------------+

buf（环形缓冲区，buffered channel 专用）是共用一个缓冲区:
+----------------------------------+
| [elem0] [elem1] ... [elemN-1]   |
+----------------------------------+
   ↑        ↑
 recvx    sendx
 ```
 recvq 和 sendq 是两个独立的双向链表里面分别存储等待接收/发送的 goroutine

 9. sync包
 * sync.Mutex (互斥锁)和 sync.RWMutex(多读单写)
 * sync.Once
 * sync.Cond(复杂条件同步较少用)
 * sync.Map (多读少写 性能较好, 写频率一旦上去 map+sync.RWMutex 性能好)

10. errorgroup
```golang

urls:=[]string{
    "url1",
    "url2",
    "url3",
}

results:=make(chan string, len(urls))

ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()

g, ctx:=errgroup.WithContext(ctx)

for _, url := range urls{
    curUrl:=url
    g.Go(func()error{
        req, err:=http.NewRequestWithContext(ctx, "GET", curUrl, nil)
        if err!=nil{
            return err
        }
        resp, err:=http.DefaultClient.Do(req)
        if err!=nil{
            return err
        }
        defer resp.Body.Close()

        body, err:=ioutil.ReadAll(resp.Body)
        if err!=nil{
            return err
        }

        select{
            case results<-string(body):
                return nil
            case <-ctx.Done():
                return ctx.Err()
        }
    })
}

go func(){
    g.Wait()
    close(results)
}()

for result:=range results{
    fmt.Print(result)
}
if err:=g.Wait();err!=nil{
    fmt.Print(err)
}
```

    1. errgroup 内部维护了一个 sync.WaitGroup 计数器和一个错误状态（通过原子操作管理）。
    2. 第一次 g.Wait() 调用会阻塞，直到 WaitGroup 计数器归零（所有 goroutine 完成）。
    3. 完成后，errgroup 记录第一个非 nil 错误（如果有），并标记任务完成。
    4. 后续的 g.Wait() 调用直接返回已记录的错误，不会再次等待。

11. context

管理 Goroutine生命周期, 传递取消信号/超时/值

12. 性能分析
    1. pprof(CPU, Memory, Goroutine, Block)抽样统计, 可长期开启
    2. trace 详细分析执行轨迹 记录全流程
    3. bench

13. test
```golang
func TestAdd(t *testing.T){
    fmt.Print(1)
}
```

14. singleton
sync.Once and init()

15. reflect
```golang
t := reflect.TypeOf(someVar)
v := reflect.ValueOf(someVar)

t.Kind()
t.Name()
...

v.Kind()
v.Type()
...
```

16. 内存模型安全
无共享内存 通过通信共享

17. GMP
* G（Goroutine）：用户态轻量级线程，执行 Go 代码的最小单位，内存占用小（约 2KB）。
* M（Machine）：操作系统线程，实际执行 Goroutine 的实体。
* P（Processor）：逻辑处理器，负责调度 Goroutine，持有 runqueue，数量由 GOMAXPROCS 决定。 P 连接 G 和 M，每个 P 绑定一个 M，P 的 runqueue 存储待运行的 G。调度器通过 work-stealing 和抢占机制确保高效并发。