## 2.3 线性代数
### 2.3.1 标量 Scalars
标量由只有一个元素的张量表示。 下面的代码将实例化两个标量，并执行一些熟悉的算术运算，即加法、乘法、除法和指数。
```python
import tensorflow as tf

x = tf.constant(3.0)
y = tf.constant(2.0)

x + y, x * y, x / y, x**y

# (<tf.Tensor: shape=(), dtype=float32, numpy=5.0>,
#  <tf.Tensor: shape=(), dtype=float32, numpy=6.0>,
#  <tf.Tensor: shape=(), dtype=float32, numpy=1.5>,
#  <tf.Tensor: shape=(), dtype=float32, numpy=9.0>)
```

### 2.3.2 Vectors
For current purposes, you can think of a vector as a fixed-length array of scalars.
```python
x = tf.range(4)
x
# <tf.Tensor: shape=(4,), dtype=int32, numpy=array([0, 1, 2, 3], dtype=int32)>
```

### 2.3.3 矩阵
当调用函数来实例化张量时， 我们可以通过指定两个分量 m 和 n 来创建一个形状为 m * n 的矩阵
```python
A = tf.reshape(tf.range(20), (5, 4))
A
# <tf.Tensor: shape=(5, 4), dtype=int32, numpy=
# array([[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
#        [ 8,  9, 10, 11],
#        [12, 13, 14, 15],
#        [16, 17, 18, 19]], dtype=int32)>

# 访问矩阵的转置
tf.transpose(A)
# <tf.Tensor: shape=(4, 5), dtype=int32, numpy=
# array([[ 0,  4,  8, 12, 16],
#        [ 1,  5,  9, 13, 17],
#        [ 2,  6, 10, 14, 18],
#        [ 3,  7, 11, 15, 19]], dtype=int32)>
```
Symmetric matrices are the subset of square matrices that are equal to their own transposes
```python
B = tf.constant([[1, 2, 3], [2, 0, 4], [3, 4, 5]])
B
# <tf.Tensor: shape=(3, 3), dtype=int32, numpy=
# array([[1, 2, 3],
#        [2, 0, 4],
#        [3, 4, 5]], dtype=int32)>

B == tf.transpose(B)
# <tf.Tensor: shape=(3, 3), dtype=bool, numpy=
# array([[ True,  True,  True],
#        [ True,  True,  True],
#        [ True,  True,  True]])>
```

### 2.3.4 Tensors
向量是一阶张量，矩阵是二阶张量。 张量用特殊字体的大写字母表示 X，Y 和 Z
```python
X = tf.reshape(tf.range(24), (2, 3, 4))
X

# 相当于 所有数据分成 2 大块 每个大块 内部 分为 3 个小块 3个小块内部在分 4个

# <tf.Tensor: shape=(2, 3, 4), dtype=int32, numpy=
# array([[[ 0,  1,  2,  3],
#         [ 4,  5,  6,  7],
#         [ 8,  9, 10, 11]],

#        [[12, 13, 14, 15],
#         [16, 17, 18, 19],
#         [20, 21, 22, 23]]], dtype=int32)>

```

### 2.3.5 张量算法的基本性质 Basic Properties of Tensor Arithmetic 
两个矩阵的按元素乘法称为Hadamard积（Hadamard product）
```python
A * B
# <tf.Tensor: shape=(5, 4), dtype=float32, numpy=
# array([[  0.,   1.,   4.,   9.],
#        [ 16.,  25.,  36.,  49.],
#        [ 64.,  81., 100., 121.],
#        [144., 169., 196., 225.],
#        [256., 289., 324., 361.]], dtype=float32)>
```

### 2.3.6 降维 Reduction 
任意形状张量的元素和
```python
# 调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量
tf.reduce_sum(A)

# 输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失
A_sum_axis0 = tf.reduce_sum(A, axis=0)
A_sum_axis0, A_sum_axis0.shape
# (<tf.Tensor: shape=(4,), dtype=float32, numpy=array([40., 45., 50., 55.], dtype=float32)>,
#  TensorShape([4]))

# 指定axis=1将通过汇总所有列的元素降维（轴1）
A_sum_axis1 = tf.reduce_sum(A, axis=1)
A_sum_axis1, A_sum_axis1.shape
# (<tf.Tensor: shape=(5,), dtype=float32, numpy=array([ 6., 22., 38., 54., 70.], dtype=float32)>,
#  TensorShape([5]))



# 用一个3维的例子加深体会
C=tf.reshape(tf.range(24),(4,3,2))
# <tf.Tensor: shape=(4, 3, 2), dtype=int32, numpy=
# array([[[ 0,  1],
#         [ 2,  3],
#         [ 4,  5]],

#        [[ 6,  7],
#         [ 8,  9],
#         [10, 11]],

#        [[12, 13],
#         [14, 15],
#         [16, 17]],

#        [[18, 19],
#         [20, 21],
#         [22, 23]]], dtype=int32)>

tf.reduce_sum(C,axis=0)
# <tf.Tensor: shape=(3, 2), dtype=int32, numpy=
# array([[36, 40],
#        [44, 48],
#        [52, 56]], dtype=int32)>
tf.reduce_sum(C,axis=1)
# <tf.Tensor: shape=(4, 2), dtype=int32, numpy=
# array([[ 6,  9],
#        [24, 27],
#        [42, 45],
#        [60, 63]], dtype=int32)>
tf.reduce_sum(C,axis=2)
# <tf.Tensor: shape=(4, 3), dtype=int32, numpy=
# array([[ 1,  5,  9],
#        [13, 17, 21],
#        [25, 29, 33],
#        [37, 41, 45]], dtype=int32)>


tf.reduce_sum(C,axis=[0,1])
# <tf.Tensor: shape=(2,), dtype=int32, numpy=array([132, 144], dtype=int32)>
tf.reduce_sum(C,axis=[1,2])
# <tf.Tensor: shape=(4,), dtype=int32, numpy=array([ 15,  51,  87, 123], dtype=int32)>
tf.reduce_sum(C,axis=[0,2])
# <tf.Tensor: shape=(3,), dtype=int32, numpy=array([ 76,  92, 108], dtype=int32)>

```
除了 reduce_sum 还有一个 reduce_mean 用法一样

### 2.3.7 非降维求和 Non-Reduction Sum
Sometimes it can be useful to keep the number of axes unchanged when invoking the function for calculating the sum or mean. This matters when we want to use the broadcast mechanism.
```python
sum_A = tf.reduce_sum(A, axis=1, keepdims=True)
sum_A
# <tf.Tensor: shape=(5, 1), dtype=float32, numpy=
# array([[ 6.],
#        [22.],
#        [38.],
#        [54.],
#        [70.]], dtype=float32)>

A / sum_A
# <tf.Tensor: shape=(5, 4), dtype=float32, numpy=
# array([[0.        , 0.16666667, 0.33333334, 0.5       ],
#        [0.18181819, 0.22727273, 0.27272728, 0.3181818 ],
#        [0.21052632, 0.23684211, 0.2631579 , 0.28947368],
#        [0.22222222, 0.24074075, 0.25925925, 0.2777778 ],
#        [0.22857143, 0.24285714, 0.25714287, 0.27142859]], dtype=float32)>


# 如果我们想沿某个轴计算A元素的累积总和， 比如axis=0（按行计算），可以调用cumsum函数。 此函数不会沿任何轴降低输入张量的维度。
tf.cumsum(A, axis=0)

# <tf.Tensor: shape=(5, 4), dtype=float32, numpy=
# array([[ 0.,  1.,  2.,  3.],
#        [ 4.,  6.,  8., 10.],
#        [12., 15., 18., 21.],
#        [24., 28., 32., 36.],
#        [40., 45., 50., 55.]], dtype=float32)>
```

### 2.3.8 Dot Products
Given two vectors their dot product is 
$x · y = \sum_{d}^{i=1}x_iy_i$

```python
y = tf.ones(3, dtype=tf.float32)
x, y, tf.tensordot(x, y, axes=1)
# (<tf.Tensor: shape=(3,), dtype=float32, numpy=array([0., 1., 2.], dtype=float32)>,
#  <tf.Tensor: shape=(3,), dtype=float32, numpy=array([1., 1., 1.], dtype=float32)>,
#  <tf.Tensor: shape=(), dtype=float32, numpy=3.0>)

# Equivalently, we can calculate the dot product of two vectors by performing an elementwise multiplication followed by a sum:
tf.reduce_sum(x * y)
```

### 2.3.9 矩阵向量积 Matrix-Vector Products
```python
A.shape, x.shape, tf.linalg.matvec(A, x)
# (TensorShape([2, 3]),
#  TensorShape([3]),
#  <tf.Tensor: shape=(2,), dtype=float32, numpy=array([ 5., 14.], dtype=float32)>)
```

### 2.3.10 矩阵矩阵乘法 matrix-matrix multiplication
```python
B = tf.ones((4, 3), tf.float32)
tf.matmul(A, B)
# <tf.Tensor: shape=(5, 3), dtype=float32, numpy=
# array([[ 6.,  6.,  6.],
#        [22., 22., 22.],
#        [38., 38., 38.],
#        [54., 54., 54.],
#        [70., 70., 70.]], dtype=float32)>
```

### 2.3.11 范数 Norms
在数学中，范数（Norm）是一种衡量向量空间中向量大小的方式。范数本质上是一个函数，它将向量映射到非负实数集合中。它衡量了向量的大小或长度。
范数可以是多种形式，其中最常见的是 $L^p$范数
* $L^1$范数(曼哈顿距离): 衡量了向量中所有元素绝对值的总和，也被称为曼哈顿距离，因为它类似于在城市中沿着网格街道行走的距离。 $ ||x||_1 = \sum_{i=1}^n|x_i|$
* $L^2$范数(欧几里得距离): 向量元素平方和的平方根，也称为欧几里得距离，它在几何空间中用于测量两点之间的直线距离。$ ||x||_2 = \sqrt[2]{\sum_{n=1}^nx_i^2}$
* $L^p$范数 $ ||x||_p = (\sum_{i=1}^n|x_i|^p)^{\frac{1}{p}} $ 其中 p>=1

A norm is a function ||·|| that maps a vector to a scalar and satisfies the following three properties:
1. $ || α x|| = |α| ||x|| $
2. $ |||x+y|| <= ||x|| + ||y|| $
3. $ ||x|| > 0 $ for all $ x != 0 $


不同的 Lp 范数在数学和工程领域有不同的应用，选择不同的范数可以根据具体问题的特点来衡量向量的大小或距离

```python

u = tf.constant([3.0,-4.0])

# l1 norm
tf.reduce_sum(tf.abs(u))

# l2 norm
tf.norm(u)

```

类似于向量的 $L_2$范数, 矩阵 $ X \in R $ 的Frobenius范数 是 矩阵元素平方和的平方根
$ ||X||_F = \sqrt{\sum_{i=1}^m\sum_{j=1}^nx_{ij}^2} $ 调用以下函数将计算矩阵的Frobenius范数。
```python
tf.norm(tf.ones((4,9)))
# <tf.Tensor: shape=(), dtype=float32, numpy=6.0>
```

### 2.3.12 范数和目标
在深度学习中，我们经常试图解决优化问题： 最大化分配给观测数据的概率; 最小化预测和真实观测之间的距离。 用向量表示物品（如单词、产品或新闻文章），以便最小化相似项目之间的距离，最大化不同项目之间的距离。

目标或许是深度学习算法最重要的组成部分（除了数据），通常被表达为范数。